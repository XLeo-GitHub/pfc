from imutils import perspective
from imutils import contours
import numpy as np
import argparse
import imutils
import sys
import cv2
from matplotlib import pyplot as plt
from pprint import pprint
import time
from scipy.spatial import distance as dist


class pfc_cv_measurer:
	COIN_PX = None
	COIN_MM = None
	MAX_CONTOURS = None
	ORIGINAL_FILE_PATH = None
	IMAGES = {
							'GRAY_IMG':None,
							'GAUSSIAN_IMG' : None,
							'CANNY_IMG' : None,
							'DILATE_IMG' : None,
							'ERODE_IMG' : None,
						}
	THRESHOLD_CONTOUR_AREA = 200
	THRESHOLD_MINIMUM_SIDE = 30

	def __init__(self,coin_px=10,coin_mm=10,max_contours=20,opath=None,carea=200,min_side=30):
		None
	def get_order_points(self,pts):
		None
	def get_midpoint(self,ptA,ptB):
		None
	def calc_PxForMmRatio(self,px, mm):
		None
	def find_contours(self):
		None
	def save_images(self):
		None


if __name__ == '__main__':
	pfc_cv_measurer = pfc_cv_measurer()






# def order_points(pts):
# 	xSorted = pts[np.argsort(pts[:,0]),:]
# 	leftMost = xSorted[:2,:]
# 	rightMost = xSorted[2:,:]

# 	leftMost = leftMost[np.argsort(leftMost[:,1]),:]
# 	(tl,bl) = leftMost

# 	D = dist.cdist(tl[np.newaxis], rightMost, "euclidean")[0]
# 	(br,tr) = rightMost[np.argsort(D)[::-1], :]
# 	return np.array([tl,tr,br,bl], dtype="float32")

# def midpoint(ptA,ptB):
# 	return ((ptA[0] + ptB[0]) * 0.5,(ptA[1] + ptB[1]) * 0.5)

# def calcPxMmRatio(px,mm):
# 	return round(mm/px, 7);

# ap = argparse.ArgumentParse()
# ap.add_argument("-n", "--new", type=int, default=-1, help="wheater or not the new order points should be used")

# args = vars(ap.parse_args())


# #To final image file name which generated by openCV
# image_file_name = ""

# image_state = []
# image = cv2.imread(image_file_name)

# pimages = []

# gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
# pimages.append(gray)
# gray = cv2.GaussianBlur(gray,(1,1),0)
# edged = cv2.Canny(gray,30,40)
# edged = cv2.dilate(edged, None, iteration=1)
# pimages.append(edged)

# time.time()

# spl_image_file_name = image_file_name.split(".")
# for i,img in enumerate(pimages):
# 	cv2.imwrite(spl_image_file_name[0]+"_" + str(i) + "." + spl_image_file_name[1], img)


# #finde Contours in the edge map
# cnts = cv2.findContours(edged.copy(), cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)
# cnts = cnts[0] if imutils.is_cv2() else cnts[1]

# (cnts,_) = contours.sort_contours(cnts)
# pixelPerMetric = None

# colors = ((0,0,255), (240,0,159), (255,0,0), (255,255,0))

# orig = image.copy()

# px_mm_rate = calcPxMmratio(225.79,24)

# for (i,c) in enumerate(cnts):
# 	box = cv2.minAreaRect(c)
# 	box = cv2.cv.BoxPoints(box) if imutils.is_cv2() else cv2.boxPoints(box)
# 	box = order_points(box)

# 	(tl,tr,br,bl) = box
# 	if dist.euclidean(tl,tr) < 30 or dist.euclidean(tl,bl) < 30:
# 		continue
# 	if cv2.contourArea(c) < 200:
# 		continue

# 	cv2.drawContours(orig, [box.astype("int")], -1, (144,43,120),8)

# 	for i, (x,y) in enumerate(box):
# 		cv2.circle(orig, (int(x), int(y)),2,(0,0,255),-1)

# 	(tl,tr,br,bl) = box
# 	(tltrX, tltrY) = midpoint(tl,tr)
# 	(blbrX, blbrY) = midpoint(bl,br)
# 	(tlblX, tlblY) = midpoint(tl,bl)
# 	(trbrX, trbrY) = midpoint(tr,br)

# 	cv2.circle(orig, (int(tltrX), int(tltrY)),10,(255,0,0),-1)
# 	cv2.circle(orig, (int(blbrX), int(blbrY)),10,(255,0,0),-1)
# 	cv2.circle(orig, (int(tlblX), int(tlblY)),10,(255,0,0),-1)
# 	cv2.circle(orig, (int(trbrX), int(trbrY)),10,(255,0,0),-1)


# 	cv2.line(orig, (int(tltrX), int(tltrY)), (int(blbrX),int(blbrY)),(255,0,0),8)
# 	cv2.line(orig, (int(tlblX), int(tlblY)), (int(trbrX), int(trbrY)),(255,0,0),8)

# 	dA = dist.euclidean((tltrX, tltrY), (blbrX, blbrY))
# 	dB = dist.euclidean((tlblX, tlblY), (trbrX, trbrY))

# 	mid_point_dot = tuple(map(lambda x: int(x), midpoint((tlblX,tlblY),(trbrX, trbrY)) ))

# 	cv2.putText(orig, str( round(px_mm_rate * dA, 2)) + "mm", (mid_point_dot[0] -60, mid_point_dot[1]-60),cv2.FONT_HERSHEY_SIMPLEX,3,(102,255,255),5)
# 	cv2.putText(orig, str( rount(px_mm_rate * dB, 2)) + "mm", (mid_point_dot[0]+30,mid_point_dot[1]+30),cv2.FONT_HERSHEY_SIMPLEX, 3, (102,255,255),5)

# 	if pixelPerMetric is None :
# 		pass


# cv2.nameWindow("CV Image", cv2.WINDOW_NORMAL)
# cv2.imshow("Image",orig)
# spl_image_file_name = image_file_name.split('.')
# cv2.imwrite(spl_image_file_name[0] + "_contour." + spl_image_file_name[1], orig)























